import { Socket } from 'socket.io-client';
import SocketService from './socketService';
import UserIdManager from '@/utils/userIdManager';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { WebSocketResponse } from '@/types/gameTypes';
import { PhaseManager } from '../utils/phaseManager';
import api, { API_URL } from '@/config/axios';

class GameWebSocketService {
  private pendingRequests: Map<string, { promise: Promise<any>, timestamp: number }> = new Map();
  private gameStateCache: Map<string, { state: any, timestamp: number }> = new Map();
  private joinedGames: Set<string> = new Set();
  private pendingJoinRequests: Map<string, Promise<void>> = new Map();
  private readonly CACHE_TTL = 3000; // 3 secondes
  private readonly REQUEST_TIMEOUT = 5000; // 5 secondes
  private readonly RECONNECT_DELAY = 1000; // 1 seconde
  private cacheTimeout = 2000; // 2 secondes de cache
  private cacheData: Map<string, { data: any, timestamp: number }> = new Map();
  private phaseChangeTimestamps: Map<string, { phase: string, timestamp: number }> = new Map();
  private static instance: GameWebSocketService;

  // M√©thode pour acc√©der √† l'instance singleton
  public static getInstance(): GameWebSocketService {
    if (!GameWebSocketService.instance) {
      GameWebSocketService.instance = new GameWebSocketService();
    }
    return GameWebSocketService.instance;
  }

  /**
   * S'assure que la connexion Socket est √©tablie et que l'utilisateur a rejoint le canal du jeu
   */
  async ensureSocketConnection(gameId: string): Promise<boolean> {
    try {
      // Activer l'initialisation automatique pour les jeux
      SocketService.setAutoInit(true);
      
      // V√©rifier si un socket est d√©j√† disponible et connect√©
      const socket = await SocketService.getInstanceAsync(true);
      
      if (!socket.connected) {
        console.log(`‚ö†Ô∏è [GameWebSocket] Socket non connect√©, tentative de reconnexion...`);
        
        // Tentative de reconnexion imm√©diate (sans d√©lai)
        const reconnected = await this.reconnect();
        if (!reconnected) {
          console.error(`‚ùå [GameWebSocket] √âchec de reconnexion`);
          return false;
        }
      }
      
      // S'assurer que l'utilisateur a rejoint le canal du jeu si ce n'est pas d√©j√† fait
      if (!this.joinedGames.has(gameId)) {
        // V√©rifier si une requ√™te de jointure est d√©j√† en cours
        if (this.pendingJoinRequests.has(gameId)) {
          console.log(`üîÑ [GameWebSocket] Jointure d√©j√† en cours pour ${gameId}, attente...`);
          try {
            await this.pendingJoinRequests.get(gameId);
          } catch (timeoutError) {
            console.warn(`‚ö†Ô∏è [GameWebSocket] Erreur lors de l'attente d'une jointure en cours`);
            this.pendingJoinRequests.delete(gameId);
            return false;
          }
        } else {
          // Stocker la promesse pour la jointure
          const joinPromise = this.joinGameChannel(gameId);
          this.pendingJoinRequests.set(gameId, joinPromise);
          
          try {
            await joinPromise;
          } catch (error) {
            console.error(`‚ùå [GameWebSocket] Erreur lors de la jointure au canal:`, error);
            return false;
          } finally {
            // Supprimer la requ√™te en attente
            this.pendingJoinRequests.delete(gameId);
          }
        }
      }
      
      return true;
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la v√©rification de la connexion:`, error);
      return false;
    }
  }

  /**
   * Reconnecte le socket si n√©cessaire
   */
  async reconnect(): Promise<boolean> {
    try {
      console.log(`‚ö° [GameWebSocket] Tentative de reconnexion...`);
      return await SocketService.reconnect();
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la reconnexion:`, error);
      return false;
    }
  }
  
  /**
   * Am√©lioration: D√©tecte les blocages potentiels bas√©s sur les changements de phase
   */
  detectPhaseLock(gameId: string, currentPhase: string): boolean {
    try {
      const now = Date.now();
      const lastPhaseChange = this.phaseChangeTimestamps.get(gameId);
      
      // Si nous n'avons pas de changement de phase pr√©c√©dent, enregistrer celui-ci
      if (!lastPhaseChange) {
        this.phaseChangeTimestamps.set(gameId, { phase: currentPhase, timestamp: now });
        return false;
      }
      
      // Si la phase a chang√©, mettre √† jour le timestamp
      if (lastPhaseChange.phase !== currentPhase) {
        this.phaseChangeTimestamps.set(gameId, { phase: currentPhase, timestamp: now });
        return false;
      }
      
      // V√©rifier si nous sommes bloqu√©s dans la m√™me phase depuis trop longtemps
      const timeSinceLastChange = now - lastPhaseChange.timestamp;
      
      // Diff√©rents seuils selon la phase
      const thresholds: Record<string, number> = {
        'answer': 60000,   // 1 minute en phase r√©ponse
        'vote': 45000,     // 45 secondes en phase vote
        'results': 30000,  // 30 secondes en phase r√©sultats
        'question': 20000  // 20 secondes en phase question
      };
      
      const threshold = thresholds[currentPhase] || 60000;
      
      if (timeSinceLastChange > threshold) {
        console.warn(`‚ö†Ô∏è [GameWebSocket] Blocage potentiel d√©tect√©: phase ${currentPhase} active depuis ${Math.floor(timeSinceLastChange / 1000)} secondes`);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la d√©tection de blocage:`, error);
      return false;
    }
  }
  
  /**
   * Force la transition vers la phase answer pour corriger les blocages
   * @param gameId ID du jeu √† modifier
   * @returns Promise<boolean> indiquant si l'op√©ration a r√©ussi
   */
  async forceTransitionToAnswer(gameId: string): Promise<boolean> {
    try {
      console.log(`üîÑ [GameWebSocket] Tentative de forcer la phase answer pour le jeu ${gameId}`);
      
      // Attendre que le socket soit connect√©
      const isConnected = await this.ensureSocketConnection(gameId);
      if (!isConnected) {
        console.error(`‚ùå [GameWebSocket] Socket non connect√©, impossible de forcer la transition`);
        return false;
      }
      
      const socket = await SocketService.getInstanceAsync();
      
      return new Promise((resolve, reject) => {
        // √âmettre imm√©diatement l'√©v√©nement pour forcer la phase answer
        socket.emit('game:force_phase', {
          gameId,
          targetPhase: 'answer'
        }, (response: any) => {
          if (response && response.success) {
            console.log(`‚úÖ [GameWebSocket] Transition forc√©e r√©ussie vers phase answer`);
            resolve(true);
          } else {
            console.error(`‚ùå [GameWebSocket] √âchec de la transition forc√©e:`, response?.error || 'Raison inconnue');
            resolve(false);
          }
        });
      });
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la transition forc√©e:`, error);
      return false;
    }
  }

  /**
   * Am√©lioration: Tente de r√©cup√©rer d'un blocage de phase
   */
  async recoverFromPhaseLock(gameId: string): Promise<boolean> {
    try {
      console.log(`üîÑ [GameWebSocket] Tentative de r√©cup√©ration de blocage pour ${gameId}...`);
      
      // 1. Forcer une v√©rification de phase sur le serveur via HTTP
      const userId = await UserIdManager.getUserId();
      await api.post(`${API_URL}/games/${gameId}/force-check-phase`, {
        user_id: userId
      });
      
      // 2. R√©initialiser le cache local
      this.clearGameStateCache(gameId);
      
      // 3. Forcer l'obtention d'un nouvel √©tat
      await this.getGameState(gameId);

      console.log(`‚úÖ [GameWebSocket] R√©cup√©ration de blocage tent√©e pour ${gameId}`);
      return true;
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] √âchec de r√©cup√©ration de blocage:`, error);
      return false;
    }
  }

  /**
   * Nettoie le cache d'√©tat pour un jeu sp√©cifique
   */
  clearGameStateCache(gameId: string): void {
    this.gameStateCache.delete(gameId);
    this.cacheData.delete(gameId);
    console.log(`üßπ [GameWebSocket] Cache nettoy√© pour le jeu ${gameId}`);
  }
  
  /**
   * V√©rifie si l'utilisateur actuel est l'h√¥te de la partie
   * Am√©lioration pour utiliser les infos en cache si disponibles
   */
  async isUserHost(gameId: string): Promise<boolean> {
    try {
      // V√©rifier d'abord dans le cache en m√©moire
      const cachedState = this.gameStateCache.get(gameId)?.state;
      
      if (cachedState) {
        const userId = await UserIdManager.getUserId();
        if (!userId) {
          console.error('‚ùå ID utilisateur non disponible');
          return false;
        }
        
        const isHost = String(cachedState.room?.hostId) === String(userId);
        console.log(`üóÑÔ∏è [GameWebSocket] Utilisation des informations d'h√¥te en cache pour ${gameId}: ${isHost}`);
        return isHost;
      }
      
      // Si pas en cache, v√©rifier via AsyncStorage
      try {
        const cachedInfo = await AsyncStorage.getItem(`@game_host_${gameId}`);
        if (cachedInfo) {
          const { hostId, timestamp } = JSON.parse(cachedInfo);
          const userId = await UserIdManager.getUserId();
          
          if (!userId) {
            console.error('‚ùå ID utilisateur non disponible');
            return false;
          }
          
          // N'utiliser le cache que s'il est r√©cent (5 minutes max)
          if (Date.now() - timestamp < 5 * 60 * 1000) {
            const isHost = String(hostId) === String(userId);
            console.log(`üóÑÔ∏è [GameWebSocket] Utilisation des informations d'h√¥te persistantes pour ${gameId}: ${isHost}`);
            return isHost;
          }
        }
      } catch (cacheError) {
        console.warn(`‚ö†Ô∏è [GameWebSocket] Erreur lors de la lecture du cache:`, cacheError);
      }
      
      // Si aucune information en cache, v√©rifier via le serveur
      const socket = await SocketService.getInstanceAsync();
      return new Promise<boolean>((resolve) => {
        const userId = UserIdManager.getUserId();
        if (!userId) {
          console.error('‚ùå ID utilisateur non disponible');
          resolve(false);
          return;
        }
        
        socket.emit('game:check_host', { gameId, userId }, (response: any) => {
          const isHost = response?.isHost || false;
          console.log(`üëë [GameWebSocket] R√©sultat v√©rification h√¥te serveur pour ${gameId}: ${isHost}`);
          resolve(isHost);
        });
      });
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la v√©rification d'h√¥te:`, error);
      return false;
    }
  }

  /**
   * Rejoint le canal d'un jeu sp√©cifique
   * @param gameId ID du jeu √† rejoindre
   * @returns Promise r√©solu quand le jeu est rejoint
   */
  async joinGameChannel(gameId: string): Promise<void> {
    try {
      console.log(`üéÆ [GameWebSocket] Tentative de rejoindre le jeu ${gameId}`);
      
      // S'assurer que la connexion socket est √©tablie
      const socket = await SocketService.getInstanceAsync();
      
      if (!socket.connected) {
        console.warn(`‚ö†Ô∏è [GameWebSocket] Socket non connect√©, tentative de reconnexion...`);
        await this.reconnect();
      }
      
      // R√©cup√©rer l'ID utilisateur
      const userId = await UserIdManager.getUserId();
      
      return new Promise<void>((resolve, reject) => {
        // √âmettre imm√©diatement l'√©v√©nement pour rejoindre le jeu
        socket.emit('join-game', { 
          gameId,
          userId,
          timestamp: Date.now()
        });
        
        // √âcouter la confirmation
        socket.once('game:joined', (data) => {
          if (data && data.gameId === gameId) {
            console.log(`‚úÖ [GameWebSocket] Jeu ${gameId} rejoint avec succ√®s`);
            this.joinedGames.add(gameId);
            resolve();
          } else {
            reject(new Error('Donn√©es de confirmation incorrectes'));
          }
        });
        
        console.log(`üì§ [GameWebSocket] Demande de rejoindre le jeu ${gameId} envoy√©e`);
        
        // R√©soudre imm√©diatement pour ne pas bloquer
        resolve();
      });
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la tentative de rejoindre le jeu ${gameId}:`, error);
      throw error;
    }
  }

  /**
   * Nettoie les ressources li√©es √† un jeu
   */
  async cleanupGameResources(gameId: string): Promise<void> {
    try {
      console.log(`üßπ [GameWebSocket] Nettoyage des ressources pour le jeu ${gameId}`);
      
      // Quitter le canal de jeu
      if (this.joinedGames.has(gameId)) {
        await this.leaveGameChannel(gameId);
      }
      
      // Nettoyer le cache pour ce jeu
      this.clearGameStateCache(gameId);
      
      // Supprimer les timestamps de phase
      this.phaseChangeTimestamps.delete(gameId);
      
      // Si c'√©tait le dernier jeu, d√©sactiver l'initialisation automatique
      if (this.joinedGames.size === 0) {
        SocketService.setAutoInit(false);
        console.log(`üîå [GameWebSocket] D√©sactivation de l'initialisation auto (aucun jeu actif)`);
      }
      
      console.log(`‚úÖ [GameWebSocket] Ressources nettoy√©es pour le jeu ${gameId}`);
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors du nettoyage des ressources:`, error);
    }
  }

  /**
   * R√©cup√®re l'√©tat complet d'un jeu
   * @param gameId ID du jeu
   * @param forceRefresh Forcer une actualisation (ignorer le cache)
   * @returns Promise avec l'√©tat du jeu
   */
  async getGameState(gameId: string, forceRefresh: boolean = false): Promise<any> {
    try {
      console.log(`üéÆ [GameWebSocket] R√©cup√©ration de l'√©tat du jeu ${gameId}${forceRefresh ? ' (forc√©e)' : ''}`);
      
      // V√©rifier le cache si on ne force pas le rafra√Æchissement
      if (!forceRefresh) {
        const cachedState = this.gameStateCache.get(gameId);
        if (cachedState && Date.now() - cachedState.timestamp < this.CACHE_TTL) {
          console.log(`üóÑÔ∏è [GameWebSocket] Utilisation du cache pour le jeu ${gameId}`);
          return cachedState.state;
        }
      }
      
      // Assurer que le socket est connect√©
      await this.ensureSocketConnection(gameId);
      
      // R√©cup√©rer l'ID utilisateur
      const userId = await UserIdManager.getUserId();
      if (!userId) {
        throw new Error("ID utilisateur non disponible");
      }
      
      // √âmettre une requ√™te pour obtenir l'√©tat du jeu
      return new Promise((resolve, reject) => {
        const socket = SocketService.getSocketInstance();
        
        if (!socket) {
          reject(new Error("Socket non disponible"));
          return;
        }
        
        // √âmettre la requ√™te
        socket.emit('game:get_state', { gameId, userId }, (response: any) => {
          if (response && response.success) {
            // Sauvegarder dans le cache
            this.gameStateCache.set(gameId, {
              state: response.data,
              timestamp: Date.now()
            });
            
            // Stocker les informations d'h√¥te si disponibles
            if (response.data?.room?.hostId) {
              this.storeHostInfo(gameId, response.data.room.hostId);
            }
            
            // Mettre √† jour le timestamp de phase
            if (response.data?.room?.currentPhase) {
              this.phaseChangeTimestamps.set(gameId, {
                phase: response.data.room.currentPhase,
                timestamp: Date.now()
              });
            }
            
            resolve(response.data);
          } else {
            reject(new Error(response?.error || "√âchec de r√©cup√©ration de l'√©tat du jeu"));
          }
        });
      });
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors de la r√©cup√©ration de l'√©tat du jeu:`, error);
      throw error;
    }
  }

  /**
   * Force une v√©rification de phase du jeu c√¥t√© serveur
   * @param gameId ID du jeu
   * @returns Promise<boolean> indiquant si l'op√©ration a r√©ussi
   */
  async forceCheckPhase(gameId: string): Promise<boolean> {
    try {
      console.log(`üîÑ [GameWebSocket] For√ßage de v√©rification de phase pour le jeu ${gameId}`);
      
      // Assurer que le socket est connect√©
      await this.ensureSocketConnection(gameId);
      
      // R√©cup√©rer l'ID utilisateur
      const userId = await UserIdManager.getUserId();
      
      return new Promise<boolean>((resolve) => {
        const socket = SocketService.getSocketInstance();
        
        if (!socket) {
          console.error(`‚ùå [GameWebSocket] Socket non disponible pour force check`);
          resolve(false);
          return;
        }
        
        // √âmettre la requ√™te
        socket.emit('game:force_check', { gameId, userId }, (response: any) => {
          if (response && response.success) {
            console.log(`‚úÖ [GameWebSocket] V√©rification forc√©e r√©ussie pour ${gameId}`);
            
            // Nettoyer le cache pour forcer un rafra√Æchissement
            this.clearGameStateCache(gameId);
            
            resolve(true);
          } else {
            console.warn(`‚ö†Ô∏è [GameWebSocket] √âchec de la v√©rification forc√©e: ${response?.error || 'Raison inconnue'}`);
            resolve(false);
          }
        });
      });
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors du for√ßage de v√©rification:`, error);
      return false;
    }
  }

  /**
   * Stocke les informations d'h√¥te localement
   */
  private async storeHostInfo(gameId: string, hostId: string | number): Promise<void> {
    try {
      const userId = await UserIdManager.getUserId();
      const isHost = String(hostId) === String(userId);
      
      await AsyncStorage.setItem(`@game_host_${gameId}`, JSON.stringify({
        hostId: String(hostId),
        timestamp: Date.now(),
        isHost
      }));
    } catch (error) {
      console.warn(`‚ö†Ô∏è [GameWebSocket] Erreur lors du stockage des infos d'h√¥te:`, error);
    }
  }

  /**
   * Quitte le canal de jeu
   */
  async leaveGameChannel(gameId: string): Promise<void> {
    try {
      if (!this.joinedGames.has(gameId)) {
        return; // D√©j√† quitt√©
      }
      
      const socket = await SocketService.getInstanceAsync();
      
      return new Promise<void>((resolve) => {
        socket.emit('leave-game', { gameId }, () => {
          this.joinedGames.delete(gameId);
          resolve();
        });
        
        // Supprimer du cache de toute fa√ßon
        this.joinedGames.delete(gameId);
      });
    } catch (error) {
      console.error(`‚ùå [GameWebSocket] Erreur lors du d√©part du jeu ${gameId}:`, error);
      this.joinedGames.delete(gameId);
    }
  }
}

// Modification de l'export pour utiliser √† la fois l'instance et les m√©thodes statiques
const gameWebSocketService = new GameWebSocketService();

// Ajout des fonctions statiques pour maintenir la compatibilit√© avec le code existant
export const isUserHost: (gameId: string) => Promise<boolean> = gameWebSocketService.isUserHost.bind(gameWebSocketService);

// Exporter l'instance principale comme exportation par d√©faut
export default gameWebSocketService;

// Exporter le service instantan√© avec un nom sp√©cifique
export { gameWebSocketService as InstantGameWebSocketService };
