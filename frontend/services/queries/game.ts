import api from '@/config/axios';
import { Answer, GameState } from '@/types/gameTypes';
import NetInfo from '@react-native-community/netinfo';
import AsyncStorage from '@react-native-async-storage/async-storage';
import UserIdManager from '@/utils/userIdManager';
import GameWebSocketService from '../gameWebSocketService';

class GameService {
  // Cache pour stocker temporairement les √©tats des jeux
  private gameStateCache: Map<string, {state: any, timestamp: number}> = new Map();
  private socketEnabled: boolean = true;
  private socketFailCounter: number = 0;
  private readonly MAX_SOCKET_FAILS = 3;
  private readonly SOCKET_RESET_INTERVAL = 60000; // 1 minute

  constructor() {
    // V√©rifier p√©riodiquement si on peut r√©activer le socket
    setInterval(() => {
      if (!this.socketEnabled && this.socketFailCounter < this.MAX_SOCKET_FAILS) {
        console.log('üîÑ GameService: Tentative de r√©activation du WebSocket');
        this.socketEnabled = true;
      }
    }, this.SOCKET_RESET_INTERVAL);
  }

  // R√©cup√©rer l'√©tat actuel du jeu, priorit√© au WebSocket
  async getGameState(gameId: string, retryCount = 0, maxRetries = 3, forceWebSocket = true) {
    console.log(`üéÆ GameService: R√©cup√©ration de l'√©tat du jeu ${gameId}${forceWebSocket ? ' (WebSocket forc√©)' : ''}`);

    try {
      // V√©rification de la connexion internet
      const netInfo = await NetInfo.fetch();
      if (!netInfo.isConnected) {
        console.warn('‚ö†Ô∏è Pas de connexion internet disponible');
        
        // En cas de d√©connexion, essayer d'utiliser le cache
        const cachedData = this.gameStateCache.get(gameId);
        if (cachedData && Date.now() - cachedData.timestamp < 30000) { // Cache de 30 secondes
          console.log(`üóÑÔ∏è GameService: Utilisation du cache pour ${gameId} en mode hors ligne`);
          return cachedData.state;
        }
        
        throw new Error('Pas de connexion internet. Veuillez v√©rifier votre connexion et r√©essayer.');
      }

      // R√©cup√©rer l'ID utilisateur avant l'appel pour le d√©bogage et les v√©rifications
      let userId = undefined;
      try {
        userId = await UserIdManager.getUserId();
        console.log(`üîë ID utilisateur d√©tect√©: ${userId || 'Non disponible'}`);
      } catch (err) {
        console.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration de l\'ID utilisateur:', err);
      }

      // Essayer d'abord via WebSocket (nouvelle m√©thode pr√©f√©r√©e) si le socket est activ√©
      if (this.socketEnabled || forceWebSocket) {
        try {
          // V√©rifier que la connexion WebSocket est bien √©tablie avant de continuer
          await GameWebSocketService.ensureSocketConnection(gameId);
          
          console.log(`üîå Tentative de r√©cup√©ration via WebSocket pour ${gameId}`);
          const gameData = await GameWebSocketService.getGameState(gameId);
          
          // R√©initialiser le compteur d'√©checs puisque √ßa a fonctionn√©
          this.socketFailCounter = 0;
          this.socketEnabled = true;
          
          // Correction du statut isTargetPlayer si n√©cessaire
          if (gameData.currentQuestion?.targetPlayer && userId) {
            const targetId = String(gameData.currentQuestion.targetPlayer.id);
            const userIdStr = String(userId);
            
            const isReallyTarget = targetId === userIdStr;
            
            if (gameData.currentUserState && gameData.currentUserState.isTargetPlayer !== isReallyTarget) {
              console.log(`üîß Correction d'incoh√©rence isTargetPlayer: ${gameData.currentUserState.isTargetPlayer} => ${isReallyTarget}`);
              gameData.currentUserState.isTargetPlayer = isReallyTarget;
            }
          }
          
          // Mettre en cache l'√©tat du jeu r√©cup√©r√©
          this.gameStateCache.set(gameId, {
            state: gameData,
            timestamp: Date.now()
          });
          
          // Stocker √©galement dans AsyncStorage pour une persistance plus longue
          this.persistGameState(gameId, gameData);
          
          return gameData;
        } catch (wsError) {
          console.error(`‚ùå Erreur lors de la r√©cup√©ration via WebSocket:`, wsError);
          
          // Incr√©menter le compteur d'√©checs du WebSocket
          this.socketFailCounter++;
          
          // Si on a d√©pass√© le nombre maximum d'√©checs, d√©sactiver temporairement le WebSocket
          if (this.socketFailCounter >= this.MAX_SOCKET_FAILS) {
            console.warn(`‚ö†Ô∏è Trop d'√©checs WebSocket (${this.socketFailCounter}). WebSocket temporairement d√©sactiv√©.`);
            this.socketEnabled = false;
          }
          
          // Si forceWebSocket est activ√©, on r√©essaie encore une fois sans forcage avant de passer au REST
          if (forceWebSocket) {
            console.log('üîÑ Nouvelle tentative sans forcage WebSocket...');
            return this.getGameState(gameId, retryCount, maxRetries, false);
          }
          
          // Sinon on continue avec fallback REST API
        }
      }
      
      // V√©rifier si on a des donn√©es en cache r√©centes avant de passer √† l'API REST
      const cachedData = this.gameStateCache.get(gameId);
      if (cachedData && Date.now() - cachedData.timestamp < 5000) { // Cache tr√®s r√©cent (5 secondes)
        console.log(`üóÑÔ∏è GameService: Utilisation du cache r√©cent pour ${gameId} au lieu de l'API REST`);
        return cachedData.state;
      }
      
      // Fallback via REST API comme avant
      console.log(`üîÑ Fallback √† l'API REST pour r√©cup√©rer l'√©tat du jeu ${gameId}`);
      
      // Le reste du code reste le m√™me
      const url = `/games/${gameId}`;
      console.log('üîê API Request: GET', url);
      
      // Appliquer l'ID utilisateur aux headers de mani√®re s√©curis√©e
      if (userId && api && api.defaults) {
        api.defaults.headers.userId = String(userId);
      }
      
      const response = await api.get(url);
      console.log('‚úÖ GameService: √âtat du jeu', gameId, 'r√©cup√©r√© avec succ√®s');
      
      // V√©rifier si la r√©ponse est correcte et a les propri√©t√©s attendues
      if (!response.data?.data?.game) {
        console.warn('‚ö†Ô∏è Structure de r√©ponse inattendue:', response.data);
        throw new Error('Donn√©es de jeu incompl√®tes');
      }
      
      // Le reste de la m√©thode reste inchang√© pour la manipulation des donn√©es
      const gameData = response.data.data;
      
      // Assurer que le joueur cible est correctement identifi√©
      if (gameData.currentQuestion?.targetPlayer) {
        const targetId = String(gameData.currentQuestion.targetPlayer.id);
        
        // S'assurer que isTargetPlayer est correctement d√©fini
        if (gameData.currentUserState) {
          // Convertir tous les IDs en string pour comparaison
          const userIdStr = String(userId);
          const targetIdStr = String(targetId);
          
          const isReallyTarget = Boolean(userId && targetIdStr === userIdStr);
          
          console.log(`üéØ V√©rification de cible - ID utilisateur: ${userIdStr}, ID cible: ${targetIdStr}, Correspondance: ${isReallyTarget}`);
          
          if (gameData.currentUserState.isTargetPlayer !== isReallyTarget) {
            console.warn(`‚ö†Ô∏è Correction d'incoh√©rence de joueur cible: ${gameData.currentUserState.isTargetPlayer} => ${isReallyTarget}`);
            gameData.currentUserState.isTargetPlayer = isReallyTarget;
          }
        }
      }

      // S'assurer que les r√©ponses ont bien la propri√©t√© isOwnAnswer
      if (gameData.answers && Array.isArray(gameData.answers) && userId) {
        const userIdStr = String(userId);
        gameData.answers = gameData.answers.map(answer => ({
          ...answer,
          isOwnAnswer: String(answer.playerId) === userIdStr || answer.isOwnAnswer
        }));
      }
      
      // Mettre en cache l'√©tat du jeu r√©cup√©r√© via REST API
      this.gameStateCache.set(gameId, {
        state: gameData,
        timestamp: Date.now()
      });
      
      // Stocker √©galement dans AsyncStorage pour une persistance plus longue
      this.persistGameState(gameId, gameData);
      
      return gameData;
    } catch (error) {
      console.error('‚ùå GameService: Erreur lors de la r√©cup√©ration de l\'√©tat du jeu', gameId, ':', error);
      
      // V√©rifier si on a des donn√©es en cache m√™me un peu anciennes
      const cachedData = this.gameStateCache.get(gameId);
      if (cachedData) {
        console.log(`üóÑÔ∏è GameService: Utilisation du cache comme fallback pour ${gameId}`);
        return cachedData.state;
      }
      
      // Essayer de r√©cup√©rer depuis AsyncStorage
      try {
        const persistedState = await this.loadPersistedGameState(gameId);
        if (persistedState) {
          console.log(`üíæ GameService: √âtat r√©cup√©r√© depuis le stockage persistant pour ${gameId}`);
          return persistedState;
        }
      } catch (storageError) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration depuis le stockage persistant:', storageError);
      }
      
      // Si nous n'avons pas atteint le nombre maximum de tentatives, r√©essayer
      if (retryCount < maxRetries) {
        console.log(`üîÑ GameService: Tentative #${retryCount + 1}/${maxRetries} pour r√©cup√©rer l'√©tat du jeu ${gameId}`);
        // Attendre un peu avant de r√©essayer
        await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
        return this.getGameState(gameId, retryCount + 1, maxRetries);
      }
      
      throw error;
    }
  }

  /**
   * Persiste l'√©tat du jeu dans AsyncStorage
   */
  private async persistGameState(gameId: string, state: GameState): Promise<void> {
    try {
      await AsyncStorage.setItem(
        `game_state_${gameId}`, 
        JSON.stringify({
          state,
          timestamp: Date.now()
        })
      );
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la persistence de l\'√©tat du jeu:', error);
    }
  }

  /**
   * R√©cup√®re l'√©tat du jeu depuis AsyncStorage
   */
  private async loadPersistedGameState(gameId: string): Promise<GameState | null> {
    try {
      const savedState = await AsyncStorage.getItem(`game_state_${gameId}`);
      if (savedState) {
        const parsed = JSON.parse(savedState);
        
        // V√©rifier si l'√©tat n'est pas trop ancien (moins de 5 minutes)
        if (Date.now() - parsed.timestamp < 5 * 60 * 1000) {
          return parsed.state;
        }
      }
      return null;
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur lors de la r√©cup√©ration de l\'√©tat persitant du jeu:', error);
      return null;
    }
  }

  /**
   * Force l'utilisation du WebSocket pour la prochaine requ√™te
   */
  async resetWebSocketConnection(): Promise<boolean> {
    try {
      console.log('üîÑ GameService: R√©initialisation de la connexion WebSocket');
      
      // R√©initialiser le compteur d'√©checs
      this.socketFailCounter = 0;
      this.socketEnabled = true;
      
      // Tenter une reconnexion WebSocket
      return await GameWebSocketService.reconnect();
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©initialisation de la connexion WebSocket:', error);
      return false;
    }
  }

  /**
   * Soumettre une r√©ponse √† une question uniquement via WebSocket
   */
  async submitAnswer(gameId: string, questionId: string, content: string) {
    console.log(`üéÆ GameService: Soumission de r√©ponse pour le jeu ${gameId}, question ${questionId}`);
    
    try {
      // R√©cup√©rer l'ID utilisateur pour le d√©bogage
      const userId = await UserIdManager.getUserId();
      console.log(`üë§ GameService: Soumission de r√©ponse par utilisateur ${userId}`);
      
      // S'assurer que la connexion WebSocket est active
      await GameWebSocketService.ensureSocketConnection(gameId);
      
      // Utiliser notre nouvelle m√©thode WebSocket
      return await GameWebSocketService.submitAnswer(gameId, questionId, content);
    } catch (error) {
      console.error('‚ùå GameService: Erreur lors de la soumission de la r√©ponse:', error);
      throw error;
    }
  }

  // Soumettre un vote pour une r√©ponse
  async submitVote(gameId: string, answerId: string, questionId: string) {
    console.log(`üéÆ GameService: Vote pour la r√©ponse ${answerId} dans le jeu ${gameId}`);
    
    try {
      // R√©cup√©rer l'ID utilisateur pour le d√©bogage
      const userId = await UserIdManager.getUserId();
      console.log(`üë§ GameService: Soumission de vote par utilisateur ${userId}`);
      
      // S'assurer que la connexion WebSocket est active
      await GameWebSocketService.ensureSocketConnection(gameId);
      
      // Utiliser notre nouvelle m√©thode WebSocket
      return await GameWebSocketService.submitVote(gameId, answerId, questionId);
    } catch (error) {
      console.error('‚ùå GameService: Erreur lors de la soumission du vote:', error);
      throw error;
    }
  }

  /**
   * V√©rifier si un utilisateur est l'h√¥te d'une salle ou d'un jeu
   */
  async isUserRoomHost(gameId: string | number, userId: string | number): Promise<boolean> {
    try {
      console.log(`üëë V√©rification si utilisateur ${userId} est l'h√¥te de ${gameId}`);
      
      // S'assurer que la connexion WebSocket est active
      await GameWebSocketService.ensureSocketConnection(String(gameId));
      
      // Utiliser la m√©thode WebSocket qui a d√©j√† toute la logique n√©cessaire
      return await GameWebSocketService.isUserHost(String(gameId));
    } catch (error) {
      console.error(`‚ùå Erreur lors de la v√©rification de l'h√¥te:`, error);
      return false;
    }
  }

  /**
   * Passer au tour suivant
   */
  async nextRound(gameId: string) {
    try {
      console.log(`üéÆ Tentative de passage au tour suivant pour le jeu ${gameId}`);
      
      // S'assurer que la connexion WebSocket est active
      const socketConnected = await this.ensureSocketConnection(gameId);
      
      if (!socketConnected) {
        console.warn("‚ö†Ô∏è Socket non connect√© avant nextRound, tentative de connexion...");
        await this.resetWebSocketConnection();
        await new Promise(resolve => setTimeout(resolve, 800)); // Attente pour √©tablir la connexion
      }
      
      try {
        // Utiliser notre nouvelle m√©thode WebSocket avec plusieurs tentatives
        let success = false;
        let attempts = 0;
        
        while (!success && attempts < 3) {
          try {
            attempts++;
            console.log(`üéÆ Tentative ${attempts}/3 de passage au tour suivant via WebSocket`);
            await GameWebSocketService.nextRound(gameId);
            success = true;
          } catch (attemptError) {
            if (attempts >= 3) throw attemptError;
            await new Promise(resolve => setTimeout(resolve, 1000)); // Attente entre les tentatives
          }
        }
        
        console.log(`‚úÖ Commande de passage au tour suivant envoy√©e avec succ√®s pour ${gameId}`);
        
        // Invalider le cache pour forcer une mise √† jour
        this.gameStateCache.delete(gameId);
        
        return { success: true };
      } catch (wsError) {
        // Si l'erreur est li√©e au statut d'h√¥te, on la g√®re sp√©cialement
        if (wsError.message && wsError.message.includes("l'h√¥te")) {
          console.warn(`‚ö†Ô∏è Acc√®s refus√©: l'utilisateur n'est pas l'h√¥te`);
          throw wsError; // On fait remonter cette erreur sp√©cifique
        }
        
        // Pour les autres erreurs, on peut essayer une approche diff√©rente
        console.warn(`‚ö†Ô∏è Erreur WebSocket, tentative via API REST: ${wsError.message}`);
        
        // Fallback vers l'API REST si possible
        const url = `/games/${gameId}/next-round`;
        const response = await api.post(url);
        
        if (response.data && response.data.status === 'success') {
          // Invalider le cache pour forcer une mise √† jour
          this.gameStateCache.delete(gameId);
          
          return { success: true };
        } else {
          throw new Error('√âchec du passage au tour suivant via API REST');
        }
      }
    } catch (error) {
      console.error(`‚ùå √âchec du passage au tour suivant:`, error);
      throw error;
    }
  }

  // Ressynchroniser la connection WebSocket si n√©cessaire
  async ensureSocketConnection(gameId: string) {
    try {
      return await GameWebSocketService.ensureSocketConnection(gameId);
    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification de la connexion WebSocket:', error);
      return false;
    }
  }

  /**
   * Force la v√©rification de la phase du jeu
   */
  async forcePhaseCheck(gameId: string): Promise<boolean> {
    try {
      // S'assurer que la connexion WebSocket est active
      await GameWebSocketService.ensureSocketConnection(gameId);
      
      return await GameWebSocketService.forceCheckPhase(gameId);
    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification forc√©e de la phase:', error);
      return false;
    }
  }

  /**
   * Nettoyer le cache interne
   */
  clearCache(gameId?: string) {
    if (gameId) {
      this.gameStateCache.delete(gameId);
      console.log(`üßπ Cache effac√© pour le jeu ${gameId}`);
    } else {
      this.gameStateCache.clear();
      console.log('üßπ Cache enti√®rement effac√©');
    }
  }
}

const gameService = new GameService();
export default gameService;
