import axios from 'axios';
import SocketService from '@/services/socketService';
import { SOCKET_URL, API_URL } from '@/config/axios';
import UserIdManager from './userIdManager';
import GameWebSocketService from '@/services/gameWebSocketService';
import { Alert } from 'react-native';

/**
 * Utilitaire pour tester la connexion WebSocket
 */
export const testSocketConnection = async () => {
  console.log('üß™ D√©marrage du test de connexion WebSocket...');
  
  try {
    // Utiliser la m√©thode asynchrone pour obtenir une instance valide
    const socket = await SocketService.getInstanceAsync();
    
    console.log(`üîå URL WebSocket: ${SOCKET_URL}`);
    console.log(`üîå Socket ID: ${socket.id || 'non connect√©'}`);
    console.log(`üîå √âtat de connexion: ${socket.connected ? 'connect√©' : 'd√©connect√©'}`);
    
    // V√©rifier d'abord si le socket est connect√© avant d'ajouter des √©couteurs
    if (!socket.connected) {
      console.log('‚ö†Ô∏è Socket non connect√©, attente de connexion...');
      return false;
    }
    
    // Ajouter un √©couteur temporaire pour les messages de test
    socket.on('pong', (data) => {
      console.log('‚úÖ R√©ponse ping re√ßue:', data);
    });
    
    // Envoyer un ping pour tester la communication bidirectionnelle
    console.log('üèì Envoi d\'un ping au serveur...');
    socket.emit('ping', (response) => {
      console.log('‚úÖ R√©ponse ping (callback) re√ßue:', response);
    });
    
    // Nettoyer les √©couteurs apr√®s 5 secondes
    setTimeout(() => {
      if (socket.connected) {
        socket.off('pong');
        console.log('üßπ √âcouteurs nettoy√©s');
      }
    }, 5000);
    
    return true;
  } catch (error) {
    console.error('‚ùå Erreur lors du test de connexion WebSocket:', error);
    return false;
  }
};

/**
 * Teste la soumission d'une r√©ponse via WebSocket, avec repli vers HTTP en cas d'√©chec
 * @param gameId ID de la partie
 * @param questionId ID de la question
 * @param content Contenu de la r√©ponse
 * @returns {Promise<boolean>} true si la soumission a r√©ussi, false sinon
 */
export const testAnswerSubmission = async (
  gameId: string | number,
  questionId: string | number,
  content: string
): Promise<boolean> => {
  console.log(`üß™ Test de soumission de r√©ponse - Game: ${gameId}, Question: ${questionId}`);
  
  try {
    // D'abord essayer via WebSocket
    console.log('üîå Tentative via WebSocket...');
    
    try {
      const result = await GameWebSocketService.submitAnswer(
        String(gameId),
        String(questionId),
        content
      );
      
      if (result) {
        console.log('‚úÖ R√©ponse soumise avec succ√®s via WebSocket');
        return true;
      }
    } catch (wsError) {
      console.warn('‚ö†Ô∏è √âchec de la soumission via WebSocket, tentative via HTTP:', wsError);
    }
    
    // Si WebSocket √©choue, utiliser HTTP comme solution de repli
    console.log('üåê Tentative via HTTP...');
    const userId = await UserIdManager.getUserId();
    
    const response = await axios.post(`${API_URL}/games/${gameId}/answer`, {
      question_id: questionId,
      content: content,
      user_id: userId,
    }, {
      headers: {
        'X-Retry-Mode': 'true',  // Indiquer qu'il s'agit d'une tentative de r√©cup√©ration
      },
      timeout: 5000  // Timeout de 5 secondes
    });
    
    if (response.data?.status === 'success') {
      console.log('‚úÖ R√©ponse soumise avec succ√®s via HTTP (solution de repli)');
      return true;
    } else {
      console.error('‚ùå √âchec de la soumission via HTTP:', response.data);
      return false;
    }
    
  } catch (error) {
    console.error('‚ùå Erreur lors du test de soumission de r√©ponse:', error);
    
    // Afficher une alerte utilisateur en cas d'√©chec complet
    Alert.alert(
      'Erreur de communication',
      'Impossible de soumettre votre r√©ponse. Veuillez v√©rifier votre connexion et r√©essayer.',
      [{ text: 'OK' }]
    );
    
    return false;
  }
};

/**
 * Teste la soumission d'un vote via HTTP REST directement
 * @param gameId ID de la partie
 * @param answerId ID de la r√©ponse
 * @param questionId ID de la question
 * @returns {Promise<boolean>} true si la soumission a r√©ussi, false sinon
 */
export const testVoteSubmission = async (
  gameId: string | number,
  answerId: string | number,
  questionId: string | number
): Promise<boolean> => {
  console.log(`üß™ Test de soumission de vote - Game: ${gameId}, Answer: ${answerId}`);
  
  try {
    // Utiliser directement le service de jeu qui int√®gre d√©j√† tous les m√©canismes de reprise
    const gameService = (await import('@/services/queries/game')).default;
    
    // Demander au service de soumettre le vote
    return await gameService.submitVote(
      String(gameId),
      String(answerId),
      String(questionId)
    );
  } catch (error) {
    console.error('‚ùå Erreur lors du test de soumission de vote:', error);
    
    // Afficher une alerte utilisateur en cas d'√©chec complet
    Alert.alert(
      'Erreur de communication',
      'Impossible de soumettre votre vote. Veuillez v√©rifier votre connexion et r√©essayer.',
      [{ text: 'OK' }]
    );
    
    return false;
  }
};

/**
 * Optimise la connexion WebSocket en cas de probl√®me
 * Cette fonction est utilis√©e par errorHandler.ts
 * @returns {Promise<boolean>} true si l'optimisation a r√©ussi, false sinon
 */
export const optimizeWebSocketConnection = async (): Promise<boolean> => {
  console.log('üîß Tentative d\'optimisation de la connexion WebSocket...');
  
  try {
    // Fermer et r√©initialiser la connexion actuelle
    await SocketService.disconnect();
    
    // Attendre un court d√©lai
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // √âtablir une nouvelle connexion
    const socket = await SocketService.getInstanceAsync(true);
    
    // V√©rifier si la nouvelle connexion est √©tablie
    if (socket && socket.connected) {
      console.log('‚úÖ Connexion WebSocket optimis√©e avec succ√®s');
      return true;
    } else {
      console.log('‚ö†Ô∏è √âchec de l\'optimisation de la connexion WebSocket');
      return false;
    }
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'optimisation de la connexion WebSocket:', error);
    return false;
  }
};

/**
 * V√©rifie l'√©tat de sant√© global des WebSockets et tente des r√©parations si n√©cessaire
 * @returns Objet avec le diagnostic et les actions effectu√©es
 */
export const diagnoseAndRepairWebSockets = async () => {
  console.log('ü©∫ Diagnostic WebSocket en cours...');
  
  const diagnostics = {
    initialSocketConnected: false,
    reconnectionAttempted: false,
    reconnectionSuccess: false,
    finalSocketConnected: false,
    latency: -1,
    repaired: false
  };
  
  try {
    // V√©rifier l'√©tat initial de la connexion
    const initialSocket = SocketService.getInstance();
    diagnostics.initialSocketConnected = initialSocket?.connected || false;
    
    if (!diagnostics.initialSocketConnected) {
      // Tenter une reconnexion
      console.log('üîÑ Tentative de reconnexion WebSocket...');
      diagnostics.reconnectionAttempted = true;
      
      // Mesurer le temps de r√©ponse
      const startTime = Date.now();
      
      try {
        const newSocket = await SocketService.getInstanceAsync(true);
        const endTime = Date.now();
        diagnostics.latency = endTime - startTime;
        diagnostics.reconnectionSuccess = newSocket?.connected || false;
        diagnostics.finalSocketConnected = newSocket?.connected || false;
        
        // Si la reconnexion a r√©ussi
        if (diagnostics.reconnectionSuccess) {
          console.log(`‚úÖ Reconnexion WebSocket r√©ussie (latence: ${diagnostics.latency}ms)`);
          diagnostics.repaired = true;
        }
      } catch (reconnectError) {
        console.error('‚ùå √âchec de la reconnexion WebSocket:', reconnectError);
      }
    } else {
      console.log('‚úÖ Connexion WebSocket d√©j√† √©tablie');
      
      // Mesurer la latence avec un ping/pong
      const startTime = Date.now();
      try {
        await new Promise<void>((resolve, reject) => {
          const timeoutId = setTimeout(() => reject(new Error('Timeout')), 3000);
          initialSocket.emit('ping', () => {
            clearTimeout(timeoutId);
            diagnostics.latency = Date.now() - startTime;
            resolve();
          });
        });
        console.log(`üìä Latence WebSocket: ${diagnostics.latency}ms`);
      } catch (pingError) {
        console.warn('‚ö†Ô∏è Erreur lors de la mesure de latence:', pingError);
      }
      
      diagnostics.finalSocketConnected = initialSocket.connected;
    }
    
    return diagnostics;
    
  } catch (error) {
    console.error('‚ùå Erreur lors du diagnostic WebSocket:', error);
    return {
      ...diagnostics,
      error: error.message
    };
  }
};

/**
 * Teste la fiabilit√© du passage au tour suivant via HTTP uniquement
 * @param gameId ID de la partie
 * @param forceAdvance Indique si le passage doit √™tre forc√©
 * @returns {Promise<boolean>} true si le passage au tour suivant a r√©ussi, false sinon
 */
export const testNextRound = async (
  gameId: string | number,
  forceAdvance: boolean = false
): Promise<boolean> => {
  try {
    console.log('üåê Test du passage au tour suivant via HTTP...');
    const userId = await UserIdManager.getUserId();
    
    if (!userId) {
      console.error('‚ùå ID utilisateur manquant pour le test next round');
      return false;
    }
    
    // Essayer avec un timeout plus court et des options plus souples
    const response = await api.post(`/games/${gameId}/next-round`, {
      user_id: userId,
      force_advance: forceAdvance,
      client_timestamp: Date.now()
    }, {
      headers: {
        'X-Direct-HTTP': 'true',
        'X-Test-Mode': 'true'
      },
      timeout: 5000 // 5 secondes
    });
    
    if (response.data?.status === 'success') {
      console.log('‚úÖ Test de passage au tour suivant r√©ussi!');
      return true;
    } else {
      console.warn('‚ö†Ô∏è R√©ponse inattendue lors du test:', response.data);
      return false;
    }
  } catch (error) {
    console.error(`‚ùå Erreur lors du test de passage au tour suivant:`, error);
    
    // Essayer via WebSocket en cas d'√©chec HTTP
    try {
      console.log('üîÑ Tentative via WebSocket apr√®s √©chec HTTP...');
      const socketModule = await import('../services/socketService');
      const socketService = socketModule.default;
      
      const socket = await socketService.getInstanceAsync();
      
      // Utiliser une promesse avec un timeout
      const result = await Promise.race([
        new Promise<boolean>((resolve) => {
          socket.emit('game:next_round', { 
            gameId, 
            forceAdvance,
            userId: UserIdManager.getUserIdSync(),
            isTest: true
          }, (response: any) => {
            resolve(response?.success === true);
          });
        }),
        new Promise<boolean>((resolve) => setTimeout(() => {
          console.log('‚è±Ô∏è Timeout de la tentative WebSocket, √©chec du test');
          resolve(false);
        }, 3000))
      ]);
      
      return result;
    } catch (socketError) {
      console.error('‚ùå √âchec √©galement de la tentative WebSocket:', socketError);
      return false;
    }
  }
};
